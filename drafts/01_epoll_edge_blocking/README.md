# 边缘模式和水平触发

## 正文

### 1.概念

Level_triggered(水平触发)

* **触发条件：** 当文件描述符（FD）**处于**可读或可写状态时，就会触发通知。
* **持续通知（关键）：** 如果处理程序（用户代码） **没有一次性处理完** （例如，读写缓冲区太小，一次读取固定大小数据），那么该 FD **仍然保持**在“就绪”状态。
* **重复返回：** 在下一次调用 `epoll_wait()` 时，只要该 FD 仍就绪（未处理完），它会**再次**被返回给用户，直到数据被完全处理。
* **潜在问题：** 如果系统中存在大量已就绪但应用程序不关心的 FD，而它们每次 `epoll_wait()` 都被返回，会**降低**应用程序查找和处理真正需要操作的 FD 的效率。

水平触发模式就像是**“只要水池里还有水，警报就会一直响”**。你必须把水（数据）完全舀干，警报才会停止。如果你只舀了一半，下次警报还会响，直到水干为止。

Edge_triggered(边缘触发)

* **触发条件（关键）：** 只有当文件描述符（FD）的**状态发生变化**时（例如，从“不可读”变为“可读”），才会触发通知。
* **通知特性：** 无论处理程序这次读写了多少数据，只要状态不再变化，`epoll_wait()`  **只会通知一次** 。
* **重新通知：** 只有当 FD 上出现 **新的 I/O 事件** （例如，有新的数据包到达，或发送缓冲区清空后再次被写满然后被清空）时，才会进行第二次通知。
* **效率优势：** 系统不会被重复返回的、未处理完的就绪 FD 淹没，因此在处理大量并发连接时，效率通常高于 Level-Triggered (LT) 模式。

阻塞 I/O (Blocking I/O)

* **操作行为：** 当应用程序调用 I/O 函数（如 **$read()$**, **$write()$**, **$accept()$**, **$connect()$**）时，如果操作无法立即完成（没有数据可读、没有空间可写等）。
* **关键特性：** 应用程序的执行流程会被 **挂起（阻塞）** ，直到该 I/O 操作满足条件并完成。
* **通俗理解：** “卡住”在调用函数那里，CPU 资源暂时被让出给其他进程，直到事件发生。
* **适用范围：** 适用于那些需要按顺序同步执行 I/O 的简单应用。

非阻塞 I/O (Non-Blocking I/O)

* **操作行为：** 当应用程序调用 I/O 函数时，不管当前是否具备 I/O 条件。
* **关键特性：** 函数会 **立即返回** ，不会阻塞调用线程。
* **返回结果：**
  * **成功：** 完成了部分或全部 I/O 操作。
  * **失败：** 设置相应的 **$errno$**，最常见的是 **$EAGAIN$** 或 **$EWOULDBLOCK$**，表示“请稍后再试”，当前无法读写。
* **用途：** 应用程序必须自己负责**轮询**或配合  **I/O 多路复用机制** （如 `epoll`）来判断何时可以进行 I/O 操作，从而避免“卡住”并实现高并发。

### 2.1 测试

#### 2.1.1 快捷指令：快速杀死测试客户端

```bash
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

#### 2.1.2 测试流程

1. 设置：注释/放开代码来设置模式
2. 运行：打开一个终端，编译并运行程序：

```bash
   xmake && xmake run draft 1
```

3. 测试：在另一个终端使用 `nc`命令连接服务器，根据需要使用&

```bash
nc 127.0.0.1 8080 &
```

4. 观察

#### 2.1.3 测试内容

##### （1）水平模式的非阻塞监听socket fd

1.设置：

- 保留  `/* sockfd：非阻塞的LT模式 */`下方的代码
- 注释 `/* sockfd：非阻塞的ET模式 */` 下方的代码

2.运行

```bash
   xmake && xmake run draft 1
```

3.测试

```bash
nc 127.0.0.1 8080 & nc 127.0.0.1 8080 & nc 127.0.0.1 8080 & nc 127.0.0.1 8080 & nc 127.0.0.1 8080 &
```

4.结果

```bash
   =================================新一轮accept()===================================
   accept()开始...
   开始休眠3秒...
   休眠3秒结束！！！
   connfd = 11
   accept()结束！！！
   =================================新一轮accept()===================================
   accept()开始...
   开始休眠3秒...
   休眠3秒结束！！！
   connfd = 12
   accept()结束！！！
   =================================新一轮accept()===================================
   accept()开始...
   开始休眠3秒...
   休眠3秒结束！！！
   connfd = 13
   accept()结束！！！
   =================================新一轮accept()===================================
   accept()开始...
   开始休眠3秒...
   休眠3秒结束！！！
   connfd = 14
   accept()结束！！！
   =================================新一轮accept()===================================
   accept()开始...
   开始休眠3秒...
   休眠3秒结束！！！
   connfd = 15
   accept()结束！！！
```

五次连接都被接受了，因为一直有新的连接未处理，所以这个文件描述符（FD）**处于**可读或状态时，一直触发通知。

5.清理

```bash
ps aux | grep "nc 127.0.0.1 8080" | grep -v grep &&
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

##### （2）边缘模式的非阻塞监听socket fd

1.设置：

- 保留 `/* sockfd：非阻塞的ET模式 */` 下方的代码
- 注释  `/* sockfd：非阻塞的LT模式 */`下方的代码

2.运行

```bash
   xmake && xmake run draft 1
```

3.测试

```bash
nc 127.0.0.1 8080 & nc 127.0.0.1 8080 & nc 127.0.0.1 8080 & nc 127.0.0.1 8080 & nc 127.0.0.1 8080 &
```

4.结果

```bash
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 12
accept()结束！！！

```

只有新事件才会通知，对于连接来说什么时新事件，就是有新连接。

第一个epoll_wait

- 第一个nc，触发了第1个状态变化事件：从“不可读”变为“可读”

- 进入accept逻辑，执行休眠

> 休眠的同时来了1个nc，触发了第2个状态变化事件：从“不可读”变为“可读”，后续的3个nc没有触发状态变化，不产生新事件，下次epoll_wait才会触发。

- 执行accept返回一个连接socket

第二个epoll_wait

- 触发了第2个状态变化事件

- 进入accept逻辑，执行休眠

  >休眠期间没有新连接，之后epoll_wait不会触发

- 执行accept返回一个连接socket

> 因为每次只处理一个，所以边缘模式如果每次不能将所有的内容读完，可能漏数据

5.清理

```bash
ps aux | grep "nc 127.0.0.1 8080" | grep -v grep &&
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

##### （3）水平触发的阻塞connect fd

1.设置：

- 保留  `/* sockfd：非阻塞的LT模式 */`下方的代码
- 注释 `/* sockfd：非阻塞的ET模式 */` 下方的代码
- 保留`/* connfd:阻塞的LT模式 */`下方的代码，注释connfd的其他模式代码
- 保留`/* 不带循环的LT模式 */`下方的代码，注释带循环的LT模式

2.运行

```bash
   xmake && xmake run draft 1
```

3.测试

```bash
// 1.连接服务器
nc 127.0.0.1 8080 
// 2.发送123456789
123456789
```

4.结果

```bash
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
============================>水平触发开始...
开始recv()...
ret = 5
收到消息:12345, 共5个字节
LT处理结束！！！
============================>水平触发开始...
开始recv()...
ret = 5
收到消息:6789
, 共5个字节
LT处理结束！！！

```

水平触发触发了2次。因为我们代码里面设置的缓冲区是5字节，每次处理5字节。处理代码一次接收不完，水平触发一直触发，直到数据全部读取完毕。当 read 阻塞时，线程确实卡在 read 上，但**当它返回后**，如果还有数据没读完，下一轮 epoll_wait 仍能通知。

5.清理

```bash
ps aux | grep "nc 127.0.0.1 8080" | grep -v grep &&
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

##### （4）水平触发的非阻塞connect fd

1.设置：

- 保留`/* connfd:非阻塞的LT模式 */`下方的代码，注释connfd的其他模式代码
- 保留`/* 不带循环的LT模式 */`下方的代码，注释带循环的LT模式

> 如果从第三个实验坐下来的只需要修改第三处的代码

2.运行

```bash
   xmake && xmake run draft 1
```

3.测试

```bash
// 1.连接服务器
nc 127.0.0.1 8080 
// 2.发送123456789
123456789
```

4.结果

```bash
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
============================>水平触发开始...
开始recv()...
ret = 5
收到消息:12345, 共5个字节
LT处理结束！！！
============================>水平触发开始...
开始recv()...
ret = 5
收到消息:6789
, 共5个字节
LT处理结束！！！

```

**水平触发触发了2次。因为我们代码里面设置的缓冲区是5字节，每次处理5字节。处理代码一次接收不完，水平触发一直触发，直到数据全部读取完毕**

5.清理

```bash
ps aux | grep "nc 127.0.0.1 8080" | grep -v grep &&
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

##### （5）边缘触发的阻塞connect fd

1.设置：

- 保留`/* connfd:阻塞的ET模式 */`下方的代码，注释connfd的其他模式代码
- 保留`/* 不带循环的ET模式 */`下方的代码，注释带循环的ET模式

2.运行

```bash
   xmake && xmake run draft 1
```

3.测试

```bash
// 1.连接服务器
nc 127.0.0.1 8080 
// 2.发送123456789
123456789
```

4.结果

```bash
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
============================>边缘触发开始...
不带循环的ET模式开始读取数据...
收到消息:12345, 共5个字节
不带循环的ET模式处理结束！！！
```

边缘触发只触发了一次，只读取了5个字节

继续在刚才的客户端发送一个字符a，告诉epoll_wait()，有新的可读事件发生：

```bash
============================>边缘触发开始...
不带循环的ET模式开始读取数据...
收到消息:6789
, 共5个字节
不带循环的ET模式处理结束！！！
```

- 边缘触发了新的事件，受到新的消息6789和回车

续在刚刚的客户端再发送一个a，客户端这个时候就会读取上次没读完的a加上次的回车符，2个字节，还剩3个字节的缓冲区就可以读取本次的a加本次的回车符共4个字节

```bash
============================>边缘触发开始...
不带循环的ET模式开始读取数据...
收到消息:a
a
, 共4个字节
不带循环的ET模式处理结束！！！
```

**我们可以看到，阻塞的边缘触发，如果不一次性读取，没有事件到来前，数据会被遗漏，并且一个事件上的数据，会干扰下一个事件！！！**

接下来，**我们就一次性读取数据，即带循环的ET模式**。注意：我们这里测试的还是边缘触发的阻塞connfd，只是换个读取数据的方式。

放开`/* 带循环的ET模式 */`下的代码，注释不带循环的ET模式

依然用一个客户端连接，发送1-9

```
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
============================>边缘触发开始...
带循环的ET读取数据开始...
收到消息:12354, 共5个字节
收到消息:6789
, 共5个字节
客户端主动关闭请求！！！
带循环的ET处理结束！！！
```

可以看到因为是阻塞IO，如果**没数据可读，它会一直等在那里，直到socket客户端主动断开连接**。**如果断开连接之前，用另一个客户端去连接，服务器不能受理这个新的客户端！！！**

5.清理

```bash
ps aux | grep "nc 127.0.0.1 8080" | grep -v grep &&
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

##### （6）边缘触发的带循环的非阻塞connect fd

1.设置：

- 保留`/* connfd:不阻塞的ET模式 */`下方的代码，注释connfd的其他模式代码
- 保留`/* 带循环的ET模式 */`下方的代码，注释带循环的ET模式

2.运行

```bash
   xmake && xmake run draft 1
```

3.测试

```bash
// 1.连接服务器
nc 127.0.0.1 8080 
// 2.发送123456789
123456789
```

4.结果

```bash
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
============================>边缘触发开始...
带循环的ET读取数据开始...
收到消息:12345, 共5个字节
收到消息:6789
, 共5个字节
循环读完所有数据！！！
带循环的ET处理结束！！！

```

数据全部读取完毕，处理函数也退出了，因为**非阻塞IO如果没有数据可读时，会立即返回，并设置error，这里我们根据EAGAIN和EWOULDBLOCK来判断数据全部读取完毕了，可以退出循环了**：

```
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
============================>边缘触发开始...
带循环的ET读取数据开始...
收到消息:12345, 共5个字节
收到消息:6789
, 共5个字节
循环读完所有数据！！！
带循环的ET处理结束！！！
```

这个时候，我们用另一个客户端去连接，服务器依然可以正常接收请求：

```
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 12
accept()结束！！！
============================>边缘触发开始...
带循环的ET读取数据开始...
收到消息:12345, 共5个字节
收到消息:6789
, 共5个字节
循环读完所有数据！！！
带循环的ET处理结束！！！
```

5.清理

```bash
ps aux | grep "nc 127.0.0.1 8080" | grep -v grep &&
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

##### （7）水平触发的带循环的阻塞connect fd

1.设置：

- 保留`/* connfd:阻塞的LT模式 */`下方的代码，注释connfd的其他模式代码
- 保留`/* 带循环的LT模式 */`下方的代码，注释不带循环的LT模式

2.运行

```bash
   xmake && xmake run draft 1
```

3.测试

```bash
// 1.连接服务器
nc 127.0.0.1 8080 
// 2.发送123456789
123456789
```

4.结果

```bash
=================================新一轮accept()===================================
accept()开始...
开始休眠3秒...
休眠3秒结束！！！
connfd = 11
accept()结束！！！
============================>水平触发开始...
LT循环读取数据开始...
收到消息:12345, 共5个字节
收到消息:6789
, 共5个字节
```

可以看到因为是阻塞IO，如果**没数据可读，它会一直等在那里，直到socket客户端主动断开连接**。**如果断开连接之前，用另一个客户端去连接，服务器不能受理这个新的客户端！！！**

循环阻塞必定会导致阻塞其他客户端连接的行为。

5.清理

```bash
ps aux | grep "nc 127.0.0.1 8080" | grep -v grep &&
kill -9 $(ps aux | grep "nc 127.0.0.1 8080" | grep -v grep | awk '{print $2}')
```

### 总结

- 对于边缘模式
  - 使用阻塞
    - 一次不读完：一个事件的缓冲区数据不被完全处理完，**缓冲区剩余数据可能永远不会被读**，除非第二个事件进来，并且数据可能会影响后续事件
    - 一次读完：使用循环保证数据被读完，因为缓冲区为空被阻塞，循环加阻塞read导致阻塞在read上，只有连接端开才能退出循环，所以**失去了io复用的意义**
  - 非阻塞：推荐，性能优秀，需要一次循环到底，代码复杂。
- 对于水平模式
  - 阻塞
    - **循环加阻塞也会失去io复用的意义**
    - 不使用循环，理想情况下，可以处理所有数据，但是如果出现多次read，很容易导致阻塞。
    - **阻塞也会导致阻塞其他io**，**只要能从阻塞返回并且有数据就会通知**
  - 非阻塞：简单，无须循环read/write到底，epoll负责重复通知。

| **模式组合**          | **单线程事件循环** | **编程复杂性**                                               |
| --------------------- | ------------------ | ------------------------------------------------------------ |
| LT + Non-Blocking I/O | **推荐**           | 简单，无须循环 read/write到底，epoll负责重复通知。           |
| ET + Non-Blocking I/O | **推荐**           | 复杂，必须循环 read/write到底，追求极致性能。                |
| LT + Blocking I/O     | **不可行**         | 导致 I/O停滞。只能用于**多线程/多进程**场景。                |
| ET + Blocking I/O     | **不可行**         | 既会导致 I/O停滞，又会导致**数据残留和丢失**。**应避免使用。** |

## 参考

- https://www.zhihu.com/question/37271342/answer/3015465189
- [虚假就绪](./虚假就绪.md)



