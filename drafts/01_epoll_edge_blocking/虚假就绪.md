# 虚假就绪

## **1. 虚假就绪的机制**

- **时序问题：** $\text{select()}$ 在检查 $\text{socket}$ 状态时，可能是在数据刚刚到达，但内核尚未完成对数据包的**完整校验**之前。它看到数据在路上，于是标记为“就绪”。
- **数据被丢弃：** 紧接着，内核发现这个数据包是损坏的（如 $\text{TCP}$ 校验和错误），为了保证数据完整性，内核会将其从接收缓冲区中丢弃。
- **结果：** 当应用程序真正调用 $\text{read()}$ 时，缓冲区已经空了。如果 $\text{socket}$ 是**阻塞**模式，$\text{read()}$ 就会一直等待新数据到来，导致应用程序停滞。

**2. $\text{man}$ 手册的建议**

$\text{man}$ 手册建议：

> “Thus it may be safer to use **$\text{O\_NONBLOCK}$** on $\text{sockets}$ that should not $\text{block}$.”

- **建议：** 应该在 $\text{socket}$ 上设置 $\text{O\_NONBLOCK}$ 标志（即将其设置为**非阻塞 $\text{I/O}$**）。
- **目的：** 如果 $\text{read()}$ 确实遭遇了虚假就绪，导致缓冲区为空，非阻塞 $\text{read()}$ 会**立即返回** $\text{-1}$ 并设置 $\text{errno}$ 为 $\text{EAGAIN}$ 或 $\text{EWOULDBLOCK}$，而**不会阻塞**主事件循环。
- **最终效果：** 应用程序可以安全地处理这个错误，继续调用 $\text{select()}$/$epoll\_wait()$，等待下一次真正的可读事件。

## 参考

- [为什么 IO 多路复用要搭配非阻塞 IO?](https://www.zhihu.com/question/37271342/answer/81808421)
